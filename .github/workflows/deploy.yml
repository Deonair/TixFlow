name: TixFlow CI/CD Deployment

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: [self-hosted, Windows, X64]

    steps:
      - name: 1. Checkout Code
        uses: actions/checkout@v4
      
      - name: 1b. Move Code to C:\TixFlow\ProjectRoot
        shell: powershell
        run: |
          New-Item -ItemType Directory -Path "C:\TixFlow\ProjectRoot" -ErrorAction SilentlyContinue | Out-Null
          Remove-Item -Path "C:\TixFlow\ProjectRoot\*" -Recurse -Force -ErrorAction SilentlyContinue
          Copy-Item -Path "${{ github.workspace }}\*" -Destination "C:\TixFlow\ProjectRoot" -Recurse -Force

      - name: 2. Set up Node.js Environment
        uses: actions/setup-node@v4
        with:
          node-version: '25'

      - name: 2b. Resolve Node Path
        shell: powershell
        run: |
          $node = (Get-Command node).Source
          echo "NODE_PATH=$node" | Out-File -FilePath $env:GITHUB_ENV -Append

      - name: 2c. Ensure MongoDB Running (Service or Local mongod)
        shell: powershell
        run: |
          $svc = Get-Service -Name 'MongoDB' -ErrorAction SilentlyContinue
          if ($svc) {
            if ($svc.Status -ne 'Running') {
              Start-Service -Name 'MongoDB'
              Write-Host 'Started MongoDB Windows service.'
            } else {
              Write-Host 'MongoDB Windows service already running.'
            }
          } else {
            Write-Host 'MongoDB service not found; trying to start local mongod.'
            $dataPath = 'C:\TixFlow\Mongo\data'
            New-Item -ItemType Directory -Path $dataPath -ErrorAction SilentlyContinue | Out-Null
            # Try common install path, fallback to custom path
            $mongod = 'C:\Program Files\MongoDB\Server\7.0\bin\mongod.exe'
            if (-not (Test-Path $mongod)) { $mongod = 'C:\Program Files\MongoDB\Server\6.0\bin\mongod.exe' }
            if (-not (Test-Path $mongod)) { $mongod = 'C:\TixFlow\Mongo\bin\mongod.exe' }
            if (Test-Path $mongod) {
              $args = "--dbpath $dataPath --bind_ip 127.0.0.1 --port 27017"
              $proc = Start-Process -FilePath $mongod -ArgumentList $args -NoNewWindow -PassThru
              Set-Content -Path 'C:\TixFlow\ProjectRoot\mongo.pid' -Value $proc.Id
              Write-Host "Started mongod. PID: $($proc.Id)"
            } else {
              Write-Host 'mongod.exe not found. Please install MongoDB or adjust path.'
            }
          }
          Start-Sleep -Seconds 3

      - name: 3. Install Frontend Dependencies
        shell: powershell
        run: npm install
        working-directory: C:\TixFlow\ProjectRoot\my-app

      - name: 4. Build Frontend for Production
        shell: powershell
        run: npm run build
        working-directory: C:\TixFlow\ProjectRoot\my-app

      - name: 5. Stop Old Backend Server (Cruciaal voor herstart)
        shell: powershell
        run: |
          # Probeer eerst via PM2 als beschikbaar
          $pm2 = Get-Command pm2 -ErrorAction SilentlyContinue
          if ($pm2) {
            $exists = pm2 list --no-color | Select-String -SimpleMatch 'tixflow-backend'
            if ($exists) {
              try { pm2 stop tixflow-backend | Out-Null } catch {}
              try { pm2 delete tixflow-backend | Out-Null } catch {}
              Write-Host "PM2 backend stopped/deleted."
            } else {
              Write-Host "PM2: process 'tixflow-backend' not found; skipping stop/delete."
            }
          }

          $pidFile = "C:\TixFlow\ProjectRoot\backend.pid"
          $backendPath = "C:\TixFlow\ProjectRoot\my-app\backend"

          # 1) Probeer eerst via PID-bestand te stoppen (meest betrouwbaar)
          if (Test-Path $pidFile) {
            try {
              $pid = Get-Content $pidFile | Select-Object -First 1
              if ($pid) {
                Stop-Process -Id $pid -Force -ErrorAction SilentlyContinue
                Remove-Item $pidFile -Force -ErrorAction SilentlyContinue
                Write-Host "Stopped backend by PID $pid"
              } else {
                Write-Host "PID file empty. Fallback to process scan."
              }
            } catch {
              Write-Host "Stop by PID failed, fallback to process scan."
            }
          }

          # 2) Fallback: vind gerichte Node-processen die in backend draaien en stop ze
          try {
            $nodeProcs = Get-CimInstance Win32_Process | Where-Object { $_.Name -match '^node(\.exe)?$' -and $_.CommandLine -like "*${backendPath}*" }
            if ($nodeProcs) {
              foreach ($p in $nodeProcs) {
                try { Stop-Process -Id $p.ProcessId -Force -ErrorAction SilentlyContinue } catch {}
              }
              Write-Host "Stopped $($nodeProcs.Count) node backend process(es)."
            } else {
              Write-Host "No node backend process found."
            }
          } catch {
            Write-Host "Process scan failed; continuing without stopping."
          }
          # Zorg dat deze stap nooit faalt als er niets te stoppen valt
          $global:LASTEXITCODE = 0

      - name: 6. Copy Frontend Files to IIS Root
        shell: powershell
        run: |
          New-Item -ItemType Directory -Path "C:\TixFlow\wwwroot" -ErrorAction SilentlyContinue | Out-Null
          Remove-Item -Path "C:\TixFlow\wwwroot\*" -Recurse -Force -ErrorAction SilentlyContinue
          Copy-Item -Path "C:\TixFlow\ProjectRoot\my-app\dist\*" -Destination "C:\TixFlow\wwwroot" -Recurse -Force

      - name: 6c. Ensure web.config for IIS proxy
        shell: powershell
        run: |
          Copy-Item -Path "C:\TixFlow\ProjectRoot\my-app\public\web.config" -Destination "C:\TixFlow\wwwroot\web.config" -Force

      - name: 6b. Install Backend Dependencies
        shell: powershell
        run: npm install
        working-directory: C:\TixFlow\ProjectRoot\my-app\backend

      - name: 6c2. Configure PM2 auto-resurrect at startup (non-interactive)
        shell: powershell
        run: |
          # Gebruik een scheduled task onder SYSTEM zodat PM2 processen automatisch terugkomen bij boot
          npm install -g pm2
          pm2 save
          $taskName = 'PM2-Resurrect-TixFlow'
          try { schtasks /Delete /TN $taskName /F | Out-Null } catch {}
          $pm2 = Get-Command pm2 -ErrorAction Stop
          $pm2Exe = $pm2.Source
          $tr = '"' + $pm2Exe + '" resurrect'
          schtasks /Create /SC ONSTART /TN $taskName /TR $tr /RL HIGHEST /RU SYSTEM /F
          Write-Host 'Scheduled task created for PM2 resurrect at startup.'

      - name: 6d. Install PM2 (optional, no runtime start)
        shell: powershell
        run: |
          npm install -g pm2
          Write-Host "PM2 installed; runtime will be managed by Windows Service (NSSM)."

      # 6e. Install NSSM (Non-Sucking Service Manager)
      - name: 6e. Install NSSM (Non-Sucking Service Manager)
        shell: powershell
        run: |
          [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
      
          $chocoNssm = 'C:\ProgramData\chocolatey\lib\nssm\tools\nssm.exe'
          $toolsDir = 'C:\Tools\nssm'
          $fallbackExe = Join-Path $toolsDir 'nssm.exe'
          $nssmExe = $null
      
          # Als NSSM al via Chocolatey aanwezig is, gebruik die
          if (Test-Path $chocoNssm) {
            $nssmExe = $chocoNssm
          } else {
            # Probeer via Chocolatey te installeren/upgraden (zonder '||', met try/catch)
            if (Get-Command choco -ErrorAction SilentlyContinue) {
              try {
                choco install nssm -y --no-progress
              } catch {
                Write-Host ("Chocolatey install failed: {0}" -f $_.Exception.Message)
              }
              if (-not (Test-Path $chocoNssm)) {
                try {
                  choco upgrade nssm -y --no-progress
                } catch {
                  Write-Host ("Chocolatey upgrade failed: {0}" -f $_.Exception.Message)
                }
              }
              if (Test-Path $chocoNssm) { $nssmExe = $chocoNssm }
            }
      
            # Fallback: directe download + extract
            if (-not $nssmExe) {
              New-Item -ItemType Directory -Force -Path $toolsDir | Out-Null
              $zip = Join-Path $toolsDir 'nssm-2.24.zip'
              $extractDir = Join-Path $toolsDir 'extracted'
              $urls = @(
                'https://nssm.cc/release/nssm-2.24.zip',
                'https://github.com/servicemanagers/nssm/releases/download/2.24/nssm-2.24.zip'
              )
              $downloaded = $false
              foreach ($u in $urls) {
                try {
                  Invoke-WebRequest -Uri $u -OutFile $zip -UseBasicParsing -TimeoutSec 60
                  $downloaded = $true
                  break
                } catch {
                  Write-Host ("Download failed from {0}: {1}" -f $u, $_.Exception.Message)
                }
              }
              if (-not $downloaded) { throw "Failed to download NSSM zip from all sources" }
      
              Expand-Archive -Path $zip -DestinationPath $extractDir -Force
              $srcExe64 = Join-Path $extractDir 'nssm-2.24\win64\nssm.exe'
              $srcExe32 = Join-Path $extractDir 'nssm-2.24\win32\nssm.exe'
              if (Test-Path $srcExe64) { $srcExe = $srcExe64 } else { $srcExe = $srcExe32 }
              if (-not (Test-Path $srcExe)) { throw "NSSM executable not found in extracted archive" }
      
              try {
                Copy-Item -Path $srcExe -Destination $fallbackExe -Force -ErrorAction Stop
                Write-Host ("Copied NSSM to fallback: {0}" -f $fallbackExe)
              } catch {
                Write-Host ("Skip copy to fallback; file locked or in use: {0}" -f $_.Exception.Message)
              }
              if (Test-Path $fallbackExe) { $nssmExe = $fallbackExe } else { $nssmExe = $srcExe }
            }
          }
      
          if (-not (Test-Path $nssmExe)) { throw "NSSM executable not found: $nssmExe" }

          Write-Host "NSSM located at: $nssmExe"
          # Export NSSM_EXE voor volgende stappen
          Add-Content -Path $env:GITHUB_ENV -Value ("NSSM_EXE={0}" -f $nssmExe)

      - name: 6f. Configure Windows Service for backend via NSSM
        shell: powershell
        run: |
          $nssmExe = $env:NSSM_EXE
          if (-not $nssmExe -or -not (Test-Path $nssmExe)) {
            $candidates = @('C:\ProgramData\chocolatey\lib\nssm\tools\nssm.exe','C:\Tools\nssm\nssm.exe')
            foreach ($cand in $candidates) { if (Test-Path $cand) { $nssmExe = $cand; break } }
          }
          if (-not (Test-Path $nssmExe)) { throw "NSSM executable not found: $nssmExe" }
      
          $service = 'TixFlowBackend'
          $projectRoot = 'C:\TixFlow\ProjectRoot'
          $backendDir = Join-Path $projectRoot 'my-app\backend'
          $nodeExe = 'C:\Program Files\nodejs\node.exe'
          $script = Join-Path $backendDir 'index.js'
          $logDir = 'C:\TixFlow\Logs'
          New-Item -ItemType Directory -Force -Path $logDir | Out-Null
      
          # Bestaande service detecteren en veilig updaten
          $existing = Get-Service -Name $service -ErrorAction SilentlyContinue
          if ($existing) {
            Write-Host ("Service exists with status: {0}" -f $existing.Status)
            if ($existing.Status -eq 'Running') {
              & $nssmExe stop $service | Write-Output
            }
          } else {
            # Installeren via CLI (geen GUI)
            & $nssmExe install $service "$nodeExe" "$script"
          }
      
          # Configuratie en logging
          & $nssmExe set $service AppDirectory "$backendDir"
          & $nssmExe set $service Start SERVICE_AUTO_START
          & $nssmExe set $service AppStdout "$logDir\backend.out.log"
          & $nssmExe set $service AppStderr "$logDir\backend.err.log"
          & $nssmExe set $service AppStopMethodSkip 0
          & $nssmExe set $service AppThrottle 2000
          & $nssmExe set $service AppRestartDelay 5000
          # Start of herstart service en wacht totdat deze RUNNING is
          try {
            if ($existing) { & $nssmExe restart $service } else { & $nssmExe start $service }
          } catch {
            Write-Host ("nssm start/restart threw: {0}" -f $_.Exception.Message)
          }

          $maxAttempts = 15
          $attempt = 0
          $statusStr = ""
          do {
            $attempt += 1
            $statusLines = (& $nssmExe status $service) 2>&1
            $statusStr = ($statusLines | Out-String).Trim()
            Write-Host ("NSSM status attempt {0}: {1}" -f $attempt, $statusStr)
            if ($statusStr -match "SERVICE_RUNNING") { break }
            Start-Sleep -Seconds 2
          } while ($attempt -lt $maxAttempts -and $statusStr -match "SERVICE_START_PENDING")

          if ($statusStr -match "SERVICE_RUNNING") {
            Write-Host "Service reached RUNNING state."
          } else {
            Write-Host ("Service failed to reach RUNNING. Final status: {0}" -f $statusStr)
            if (Test-Path "$logDir\backend.err.log") { Write-Host "--- backend.err.log (tail) ---"; Get-Content -Path "$logDir\backend.err.log" -Tail 50 | Write-Host }
            if (Test-Path "$logDir\backend.out.log") { Write-Host "--- backend.out.log (tail) ---"; Get-Content -Path "$logDir\backend.out.log" -Tail 50 | Write-Host }
            Write-Host "SC QUERY output:"
            sc query $service
            throw "Service did not reach RUNNING state."
          }
      
          sc query $service

      - name: 7. Start Backend Server (Finale Start)
        shell: powershell
        run: |
          # Skip deze stap als NSSM-service al draait
          $svc = Get-Service -Name 'TixFlowBackend' -ErrorAction SilentlyContinue
          if ($svc -and $svc.Status -eq 'Running') {
            Write-Host 'Backend is running via NSSM; skipping manual start.'
            return
          }

          # Als PM2 beschikbaar is, beheren we de backend via PM2 en slaan deze stap over
          $pm2 = Get-Command pm2 -ErrorAction SilentlyContinue
          if (-not $pm2) {
            $node = $env:NODE_PATH
            if (-not $node) { $node = (Get-Command node).Source }
            $proc = Start-Process -FilePath $node -ArgumentList "index.js" -WorkingDirectory "C:\TixFlow\ProjectRoot\my-app\backend" -NoNewWindow -PassThru
            # Bewaar PID voor gecontroleerde stop bij volgende deploy
            Set-Content -Path "C:\TixFlow\ProjectRoot\backend.pid" -Value $proc.Id
            Write-Host "Backend started without PM2. PID: $($proc.Id)"
          } else {
            Write-Host "Backend managed by PM2 (tixflow-backend)."
          }

      - name: 8. Verify Backend Health
        shell: powershell
        run: |
          Start-Sleep -Seconds 7
          try {
            $resp = Invoke-RestMethod -Uri 'http://localhost:5050/api/health' -Method Get -TimeoutSec 5
            Write-Host ($resp | ConvertTo-Json)
          } catch {
            Write-Host "Backend health check failed."
          }

      - name: 8b. Verify IIS Proxy Health (detect 502)
        shell: powershell
        run: |
          try {
            $resp = Invoke-WebRequest -Uri 'http://localhost/api/health' -Method Get -TimeoutSec 5 -UseBasicParsing
            Write-Host "IIS proxy status: $($resp.StatusCode)"
            try { $json = $resp.Content | ConvertFrom-Json; Write-Host ($json | ConvertTo-Json) } catch { Write-Host "Non-JSON response from proxy" }
          } catch {
            Write-Host "IIS proxy health failed: $($_.Exception.Message)"
          }

      - name: 8c. Diagnostic POST tests (direct and via proxy)
        shell: powershell
        run: |
          $body = @{ name = 'Diag User'; email = "diag+$(Get-Random)@tixflow.local"; organization = 'Diag Org'; password = 'Passw0rd!' } | ConvertTo-Json
          Write-Host 'Testing direct backend POST /api/users/register'
          try {
            $resp = Invoke-WebRequest -Uri 'http://localhost:5050/api/users/register' -Method Post -ContentType 'application/json' -Body $body -TimeoutSec 8 -UseBasicParsing
            Write-Host "Direct backend register status: $($resp.StatusCode)"
            Write-Host $resp.Content
          } catch {
            Write-Host "Direct backend register failed: $($_.Exception.Message)"
          }

          Write-Host 'Testing IIS proxy POST /api/users/register'
          try {
            $resp2 = Invoke-WebRequest -Uri 'http://localhost/api/users/register' -Method Post -ContentType 'application/json' -Body $body -TimeoutSec 8 -UseBasicParsing
            Write-Host "IIS proxy register status: $($resp2.StatusCode)"
            Write-Host $resp2.Content
          } catch {
            Write-Host "IIS proxy register failed: $($_.Exception.Message)"
          }

      - name: 8d. Port and process diagnostics
        shell: powershell
        run: |
          Write-Host 'Listing listeners on :5050'
          try { netstat -ano | Select-String ':5050' | ForEach-Object { $_.Line } } catch {}
          Write-Host 'PM2 process list (if installed)'
          $pm2 = Get-Command pm2 -ErrorAction SilentlyContinue
          if ($pm2) { pm2 list } else { Write-Host 'PM2 not found' }