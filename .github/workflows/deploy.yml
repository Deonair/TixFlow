name: TixFlow Production Deploy

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: [self-hosted, Windows, X64]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Sync repository to deploy root
        shell: powershell
        run: |
          New-Item -ItemType Directory -Path "C:\TixFlow\ProjectRoot" -ErrorAction SilentlyContinue | Out-Null
          Remove-Item -Path "C:\TixFlow\ProjectRoot\*" -Recurse -Force -ErrorAction SilentlyContinue
          Copy-Item -Path "${{ github.workspace }}\*" -Destination "C:\TixFlow\ProjectRoot" -Recurse -Force

      - name: Setup Node 22 LTS
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Expose Node path (diagnostic)
        shell: powershell
        run: |
          $node = (Get-Command node).Source
          echo "NODE_PATH=$node" | Out-File -FilePath $env:GITHUB_ENV -Append

      - name: Ensure MongoDB available
        shell: powershell
        run: |
          $svc = Get-Service -Name 'MongoDB' -ErrorAction SilentlyContinue
          if ($svc) {
            if ($svc.Status -ne 'Running') {
              Start-Service -Name 'MongoDB'
              Write-Host 'Started MongoDB Windows service.'
            } else {
              Write-Host 'MongoDB Windows service already running.'
            }
          } else {
            Write-Host 'MongoDB service not found; trying local mongod and installing if needed.'
            $basePath = 'C:\TixFlow\Mongo'
            $dataPath = Join-Path $basePath 'data'
            $binPath = Join-Path $basePath 'bin'
            New-Item -ItemType Directory -Path $dataPath -ErrorAction SilentlyContinue | Out-Null
            New-Item -ItemType Directory -Path $binPath -ErrorAction SilentlyContinue | Out-Null

            # Try common install path, then custom path
            $mongod = 'C:\Program Files\MongoDB\Server\7.0\bin\mongod.exe'
            if (-not (Test-Path $mongod)) { $mongod = 'C:\Program Files\MongoDB\Server\6.0\bin\mongod.exe' }
            if (-not (Test-Path $mongod)) { $mongod = Join-Path $binPath 'mongod.exe' }

            if (-not (Test-Path $mongod)) {
              Write-Host 'mongod.exe not found; attempting to download portable MongoDB ZIP.'
              $zipCandidates = @(
                'https://fastdl.mongodb.org/windows/mongodb-windows-x86_64-7.0.14.zip',
                'https://fastdl.mongodb.org/windows/mongodb-windows-x86_64-6.0.15.zip'
              )
              $zipOut = 'C:\TixFlow\mongo.zip'
              foreach ($url in $zipCandidates) {
                try {
                  Write-Host ("Downloading MongoDB from {0}" -f $url)
                  Invoke-WebRequest -Uri $url -OutFile $zipOut -UseBasicParsing -TimeoutSec 60
                  Expand-Archive -Path $zipOut -DestinationPath $basePath -Force
                  Remove-Item $zipOut -Force -ErrorAction SilentlyContinue
                  $found = Get-ChildItem -Path $basePath -Recurse -Filter 'mongod.exe' -File | Select-Object -First 1
                  if ($found) { $mongod = $found.FullName; break }
                } catch {
                  Write-Host ("Download/expand failed: {0}" -f $_.Exception.Message)
                }
              }
            }

            if (Test-Path $mongod) {
              $args = "--dbpath $dataPath --bind_ip 127.0.0.1 --port 27017"
              Write-Host ("Starting mongod: {0} {1}" -f $mongod, $args)
              try {
                $proc = Start-Process -FilePath $mongod -ArgumentList $args -NoNewWindow -PassThru
                Set-Content -Path 'C:\TixFlow\ProjectRoot\mongo.pid' -Value $proc.Id
                Write-Host ("Started mongod. PID: {0}" -f $proc.Id)
              } catch {
                Write-Host ("Failed to start mongod: {0}" -f $_.Exception.Message)
              }
            } else {
              Write-Host 'MongoDB could not be installed automatically; please install manually or adjust path.'
            }
          }
          Start-Sleep -Seconds 3

      - name: Sync environment files (backend & frontend)
        shell: powershell
        run: |
          $root = 'C:\TixFlow\ProjectRoot'
          $secrets = 'C:\TixFlow\Secrets'
          $beEnvSrc = Join-Path $secrets 'backend\.env'
          $beEnvDst = Join-Path $root 'my-app\backend\.env'
          $feEnvProdSrc = Join-Path $secrets 'frontend\.env.production'
          $feEnvProdDst = Join-Path $root 'my-app\.env.production'
          $feEnvSrc = Join-Path $secrets 'frontend\.env'
          $feEnvDst = Join-Path $root 'my-app\.env'
          if (Test-Path $beEnvSrc) { Copy-Item -Path $beEnvSrc -Destination $beEnvDst -Force; Write-Host "Copied backend .env" } else { Write-Host "Backend .env not found in Secrets (skipping)" }
          if (Test-Path $feEnvProdSrc) { Copy-Item -Path $feEnvProdSrc -Destination $feEnvProdDst -Force; Write-Host "Copied frontend .env.production" } else { Write-Host "Frontend .env.production not found (skipping)" }
          if (Test-Path $feEnvSrc) { Copy-Item -Path $feEnvSrc -Destination $feEnvDst -Force; Write-Host "Copied frontend .env" } else { Write-Host "Frontend .env not found (skipping)" }


      - name: Generate env files from GitHub Secrets (fallback)
        shell: powershell
        env:
          APP_BASE_URL: "${{ secrets.APP_BASE_URL }}"
          MONGO_URI: "${{ secrets.MONGO_URI }}"
          SESSION_SECRET: "${{ secrets.SESSION_SECRET }}"
          RESEND_API_KEY: "${{ secrets.RESEND_API_KEY }}"
          EMAIL_FROM: "${{ secrets.EMAIL_FROM }}"
          STRIPE_SECRET_KEY: "${{ secrets.STRIPE_SECRET_KEY }}"
          STRIPE_WEBHOOK_SECRET: "${{ secrets.STRIPE_WEBHOOK_SECRET }}"
          VITE_API_BASE_URL: "${{ secrets.VITE_API_BASE_URL }}"
        run: |
          $root = 'C:\TixFlow\ProjectRoot'
          $beEnvDst = Join-Path $root 'my-app\backend\.env'
          $feEnvProdDst = Join-Path $root 'my-app\.env.production'

          if (-not (Test-Path $beEnvDst)) {
            $contentLines = @(
              'NODE_ENV=production',
              'PORT=5050',
              "APP_BASE_URL=$env:APP_BASE_URL",
              "MONGO_URI=$env:MONGO_URI",
              "SESSION_SECRET=$env:SESSION_SECRET",
              "RESEND_API_KEY=$env:RESEND_API_KEY",
              "EMAIL_FROM=$env:EMAIL_FROM",
              "STRIPE_SECRET_KEY=$env:STRIPE_SECRET_KEY",
              "STRIPE_WEBHOOK_SECRET=$env:STRIPE_WEBHOOK_SECRET"
            )
            $content = [string]::Join("`n", $contentLines)
            Set-Content -Path $beEnvDst -Value $content -NoNewline
            Write-Host "Generated backend .env from GitHub Secrets."
          } else {
            Write-Host "Backend .env already present; keeping server-side Secrets copy."
          }

          if (-not (Test-Path $feEnvProdDst)) {
            $contentFeLines = @(
              "VITE_API_BASE_URL=$env:VITE_API_BASE_URL"
            )
            $contentFe = [string]::Join("`n", $contentFeLines)
            Set-Content -Path $feEnvProdDst -Value $contentFe -NoNewline
            Write-Host "Generated frontend .env.production from GitHub Secrets."
          } else {
            Write-Host "Frontend .env.production already present; keeping server-side Secrets copy."
          }

      - name: Install frontend dependencies (npm ci)
        shell: powershell
        working-directory: C:\TixFlow\ProjectRoot\my-app
        run: |
          if (Test-Path 'package-lock.json') {
            Write-Host 'Using npm ci for deterministic install'
            npm ci
          } else {
            Write-Host 'No package-lock.json; falling back to npm install'
            npm install
          }

      - name: Build frontend (production)
        shell: powershell
        run: npm run build
        working-directory: C:\TixFlow\ProjectRoot\my-app

      - name: Stop previous backend instance
        shell: powershell
        run: |
          # Probeer eerst via PM2 als beschikbaar
          $pm2 = Get-Command pm2 -ErrorAction SilentlyContinue
          if ($pm2) {
            $exists = pm2 list --no-color | Select-String -SimpleMatch 'tixflow-backend'
            if ($exists) {
              try { pm2 stop tixflow-backend | Out-Null } catch {}
              try { pm2 delete tixflow-backend | Out-Null } catch {}
              Write-Host "PM2 backend stopped/deleted."
            } else {
              Write-Host "PM2: process 'tixflow-backend' not found; skipping stop/delete."
            }
          }

          $pidFile = "C:\TixFlow\ProjectRoot\backend.pid"
          $backendPath = "C:\TixFlow\ProjectRoot\my-app\backend"

          # 1) Probeer eerst via PID-bestand te stoppen (meest betrouwbaar)
          if (Test-Path $pidFile) {
            try {
              $pid = Get-Content $pidFile | Select-Object -First 1
              if ($pid) {
                Stop-Process -Id $pid -Force -ErrorAction SilentlyContinue
                Remove-Item $pidFile -Force -ErrorAction SilentlyContinue
                Write-Host "Stopped backend by PID $pid"
              } else {
                Write-Host "PID file empty. Fallback to process scan."
              }
            } catch {
              Write-Host "Stop by PID failed, fallback to process scan."
            }
          }

          # 2) Fallback: vind gerichte Node-processen die in backend draaien en stop ze
          try {
            $nodeProcs = Get-CimInstance Win32_Process | Where-Object { $_.Name -match '^node(\.exe)?$' -and $_.CommandLine -like "*${backendPath}*" }
            if ($nodeProcs) {
              foreach ($p in $nodeProcs) {
                try { Stop-Process -Id $p.ProcessId -Force -ErrorAction SilentlyContinue } catch {}
              }
              Write-Host "Stopped $($nodeProcs.Count) node backend process(es)."
            } else {
              Write-Host "No node backend process found."
            }
          } catch {
            Write-Host "Process scan failed; continuing without stopping."
          }
          # Zorg dat deze stap nooit faalt als er niets te stoppen valt
          $global:LASTEXITCODE = 0

      - name: Publish frontend to IIS
        shell: powershell
        run: |
          New-Item -ItemType Directory -Path "C:\TixFlow\wwwroot" -ErrorAction SilentlyContinue | Out-Null
          Remove-Item -Path "C:\TixFlow\wwwroot\*" -Recurse -Force -ErrorAction SilentlyContinue
          Copy-Item -Path "C:\TixFlow\ProjectRoot\my-app\dist\*" -Destination "C:\TixFlow\wwwroot" -Recurse -Force

      - name: "Publish IIS web.config (API proxy)"
        shell: powershell
        run: |
          Copy-Item -Path "C:\TixFlow\ProjectRoot\my-app\public\web.config" -Destination "C:\TixFlow\wwwroot\web.config" -Force

      # Install backend dependencies â€” redundant (handled below in PM2 start); removed

      - name: "Configure PM2 auto-resurrect at boot"
        shell: powershell
        run: |
          # Gebruik een scheduled task onder SYSTEM zodat PM2 processen automatisch terugkomen bij boot
          npm install -g pm2
          pm2 save
          $taskName = 'PM2-Resurrect-TixFlow'
          try { schtasks /Delete /TN $taskName /F | Out-Null } catch {}
          $pm2 = Get-Command pm2 -ErrorAction Stop
          $pm2Exe = $pm2.Source
          $tr = '"' + $pm2Exe + '" resurrect'
          schtasks /Create /SC ONSTART /TN $taskName /TR $tr /RL HIGHEST /RU SYSTEM /F
          Write-Host 'Scheduled task created for PM2 resurrect at startup.'

      - name: "Install PM2 globally"
        shell: powershell
        run: |
          npm install -g pm2
          Write-Host "PM2 installed; PM2 will manage the runtime."
      # NSSM niet langer gebruikt; PM2 beheert runtime

      - name: "Deploy backend via PM2"
        shell: powershell
        run: |
          $projectRoot = 'C:\TixFlow\ProjectRoot'
          $backendDir = Join-Path $projectRoot 'my-app\backend'
          $script = Join-Path $backendDir 'index.js'
          $logDir = 'C:\TixFlow\Logs'
          New-Item -ItemType Directory -Force -Path $logDir | Out-Null
          if (-not (Test-Path $script)) { throw "Backend entry script not found: $script" }

          # Zorg dat PM2 beschikbaar is
          $pm2 = Get-Command pm2 -ErrorAction SilentlyContinue
          if (-not $pm2) { npm install -g pm2 }

          # Dependencies installeren met strikte checks
          $npmCmd = (Get-Command npm -ErrorAction SilentlyContinue).Source
          if (-not $npmCmd) { $npmCmd = 'C:\Program Files\nodejs\npm.cmd' }
          Write-Host ("Installing backend dependencies in {0} (production only)..." -f $backendDir)
          Push-Location $backendDir
          $installOk = $false
          try {
            & $npmCmd ci --omit=dev
            if ($LASTEXITCODE -eq 0) { $installOk = $true } else { Write-Host ("npm ci exit code: {0}" -f $LASTEXITCODE) }
          } catch { Write-Host ("npm ci threw: {0}" -f $_.Exception.Message) }
          if (-not $installOk) {
            Write-Host "Falling back to npm install --production..."
            try {
              & $npmCmd install --production
              if ($LASTEXITCODE -eq 0) { $installOk = $true } else { Write-Host ("npm install exit code: {0}" -f $LASTEXITCODE) }
            } catch { Write-Host ("npm install threw: {0}" -f $_.Exception.Message) }
          }
          Pop-Location
          if (-not $installOk) { throw "Dependency installation failed (npm)." }
          # Verifieer kritieke packages
          $expressPkg = Join-Path $backendDir 'node_modules\express\package.json'
          $mongoosePkg = Join-Path $backendDir 'node_modules\mongoose\package.json'
          $hasExpress = Test-Path $expressPkg; $hasMongoose = Test-Path $mongoosePkg
          Write-Host ("Dependency check: express={0} mongoose={1}" -f $hasExpress, $hasMongoose)
          if (-not $hasExpress -or -not $hasMongoose) { throw ("Dependencies missing after install. express={0} mongoose={1}" -f $hasExpress, $hasMongoose) }

          # Schoon logs en (her)start via PM2 met vaste logpaden
          if (Test-Path "$logDir\backend.out.log") { Clear-Content "$logDir\backend.out.log" }
          if (Test-Path "$logDir\backend.err.log") { Clear-Content "$logDir\backend.err.log" }
          try {
            pm2 delete tixflow-backend 2>$null | Out-Null
            if ($LASTEXITCODE -ne 0) { Write-Host 'PM2 delete: process not found (ignored).' }
          } catch { Write-Host 'PM2 delete threw (ignored).'}
          pm2 start $script --name tixflow-backend --cwd $backendDir --output "$logDir\backend.out.log" --error "$logDir\backend.err.log" --time --env production
          pm2 save

          # Poll op PM2 online status (JSON) + health endpoint fallback
          $maxAttempts = 20
          $attempt = 0
          $online = $false
          $healthy = $false
          do {
            $attempt += 1
            try {
              $status = pm2 jlist --silent | node -e "const fs=require('fs');let d=fs.readFileSync(0,'utf8');d=d.replace(/^\uFEFF/, '');let a=[];try{a=JSON.parse(d);}catch(e){console.log('');process.exit(0);}const p=Array.isArray(a)?a.find(x=>x&&x.name==='tixflow-backend'):null;console.log(p&&p.pm2_env&&p.pm2_env.status?p.pm2_env.status:'');"
              if ($status) { $status = $status.Trim() } else { $status = '' }
              Write-Host ("PM2 status attempt {0}: {1}" -f $attempt, $status)
              if ($status -eq 'online') { $online = $true }
            } catch {
              Write-Host ("PM2 jlist (node parse) failed: {0}" -f $_.Exception.Message)
            }
            if (-not $healthy) {
              try {
                $resp = Invoke-RestMethod -Uri 'http://localhost:5050/api/health' -Method Get -TimeoutSec 3
                if ($resp.ok) { $healthy = $true; Write-Host ("Health check OK: {0}" -f ($resp | ConvertTo-Json)) }
              } catch { }
            }
            if ($online -or $healthy) { break }
            Start-Sleep -Seconds 2
          } while ($attempt -lt $maxAttempts)

          if ($online -or $healthy) {
            Write-Host ("Backend ready. PM2 online={0} health={1}" -f $online, $healthy)
          } else {
            Write-Host "PM2 failed to reach online status and health endpoint did not respond."
            if (Test-Path "$logDir\backend.err.log") { Write-Host "--- backend.err.log (tail) ---"; Get-Content -Path "$logDir\backend.err.log" -Tail 50 | Write-Host }
            if (Test-Path "$logDir\backend.out.log") { Write-Host "--- backend.out.log (tail) ---"; Get-Content -Path "$logDir\backend.out.log" -Tail 50 | Write-Host }
            throw "Backend did not reach ready state via PM2/health"
          }

      - name: "Confirm backend online via PM2"
        shell: powershell
        run: |
          # Skip handmatige start: PM2 beheert nu de backend
          $pm2 = Get-Command pm2 -ErrorAction SilentlyContinue
          if ($pm2) {
            $st = pm2 jlist --silent | node -e "const fs=require('fs');let d=fs.readFileSync(0,'utf8');d=d.replace(/^\uFEFF/, '');let a=[];try{a=JSON.parse(d);}catch(e){console.log('');process.exit(0);}const p=Array.isArray(a)?a.find(x=>x&&x.name==='tixflow-backend'):null;console.log(p&&p.pm2_env&&p.pm2_env.status?p.pm2_env.status:'');"
            if ($st.Trim() -eq 'online') {
              Write-Host 'Backend is running via PM2; skipping manual start.'
              return
            }
          }
          Write-Host 'PM2 niet gevonden of proces niet online; geen handmatige start hier.'

      - name: "Verify backend health"
        shell: powershell
        run: |
          Start-Sleep -Seconds 7
          try {
            $resp = Invoke-RestMethod -Uri 'http://localhost:5050/api/health' -Method Get -TimeoutSec 5
            Write-Host ($resp | ConvertTo-Json)
          } catch {
            Write-Host "Backend health check failed."
          }

      - name: "Verify IIS proxy health"
        shell: powershell
        run: |
          try {
            $resp = Invoke-WebRequest -Uri 'http://localhost/api/health' -Method Get -TimeoutSec 5 -UseBasicParsing
            Write-Host "IIS proxy status: $($resp.StatusCode)"
            try { $json = $resp.Content | ConvertFrom-Json; Write-Host ($json | ConvertTo-Json) } catch { Write-Host "Non-JSON response from proxy" }
          } catch {
            Write-Host "IIS proxy health failed: $($_.Exception.Message)"
          }

      - name: "Verify public health (best effort)"
        shell: powershell
        run: |
          try {
            $url = "${{ secrets.APP_BASE_URL }}/api/health"
            Write-Host ("Checking public URL: {0}" -f $url)
            $resp = Invoke-WebRequest -Uri $url -Method Get -TimeoutSec 6 -UseBasicParsing
            Write-Host ("Public health status: {0}" -f $resp.StatusCode)
            try { $json = $resp.Content | ConvertFrom-Json; Write-Host ($json | ConvertTo-Json) } catch { Write-Host "Public response not JSON" }
          } catch {
            Write-Host ("Public health check failed (non-blocking): {0}" -f $_.Exception.Message)
          }

      - name: "Smoke test register endpoint (direct & via proxy)"
        shell: powershell
        run: |
          $projectRoot = 'C:\TixFlow\ProjectRoot'
          $backendDir = Join-Path $projectRoot 'my-app\backend'
          $emailDiag = "diag+$(Get-Random)@tixflow.local"
          $body = @{ name = 'Diag User'; email = $emailDiag; organization = 'Diag Org'; password = 'Passw0rd!' } | ConvertTo-Json
          Write-Host 'Testing direct backend POST /api/users/register'
          try {
            $resp = Invoke-WebRequest -Uri 'http://localhost:5050/api/users/register' -Method Post -ContentType 'application/json' -Body $body -TimeoutSec 8 -UseBasicParsing
            Write-Host "Direct backend register status: $($resp.StatusCode)"
            Write-Host $resp.Content
          } catch {
            Write-Host "Direct backend register failed: $($_.Exception.Message)"
          }

          Write-Host 'Testing IIS proxy POST /api/users/register'
          try {
            $resp2 = Invoke-WebRequest -Uri 'http://localhost/api/users/register' -Method Post -ContentType 'application/json' -Body $body -TimeoutSec 8 -UseBasicParsing
            Write-Host "IIS proxy register status: $($resp2.StatusCode)"
            Write-Host $resp2.Content
          } catch {
            Write-Host "IIS proxy register failed: $($_.Exception.Message)"
          }

          # Cleanup: verwijder de diagnostische user direct uit de database
          Write-Host ("Cleanup: delete diagnostic user(s) with email: {0}" -f $emailDiag)
          Push-Location $backendDir
          $env:DIAG_EMAIL = $emailDiag
          $js = @"
          const path = require('path');
          require('dotenv').config({ path: path.join(process.cwd(), '.env') });
          const mongoose = require('mongoose');
          const email = process.env.DIAG_EMAIL;
          const uri = process.env.MONGO_URI;
          const OrganizerSchema = new mongoose.Schema({ email: String }, { collection: 'organizers' });
          const Organizer = mongoose.model('Organizer', OrganizerSchema);
          (async () => {
            try {
              await mongoose.connect(uri);
              const res = await Organizer.deleteMany({ email });
              console.log('Cleanup: deleted', res.deletedCount, 'diag user(s) with email', email);
            } catch (e) {
              console.log('Cleanup failed:', e.message);
            } finally {
              await mongoose.disconnect();
            }
          })();
          "@
          node -e $js
          Pop-Location

      - name: "Diagnostics: ports & PM2"
        shell: powershell
        run: |
          Write-Host 'Listing listeners on :5050'
          try { netstat -ano | Select-String ':5050' | ForEach-Object { $_.Line } } catch {}
          Write-Host 'PM2 process list (if installed)'
          $pm2 = Get-Command pm2 -ErrorAction SilentlyContinue
          if ($pm2) { pm2 list } else { Write-Host 'PM2 not found' }
